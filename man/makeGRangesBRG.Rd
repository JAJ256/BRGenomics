% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataset_functions.R
\name{makeGRangesBRG}
\alias{makeGRangesBRG}
\title{Make base-pair resolution GRanges object}
\usage{
makeGRangesBRG(dataset.gr)
}
\arguments{
\item{dataset.gr}{A disjoint GRanges object}
}
\value{
A GRanges object for which \code{length(output) ==
  sum(width(dataset.gr))}, and for which \code{all(width(output) == 1)}.
}
\description{
Splits up all ranges in \code{dataset.gr} to be each 1 basepair wide. For any
range that is split up, all metadata information belonging to that range is
inherited by its daughter ranges, and therefore the transformation is
non-destructive.
}
\details{
Note that this function doesn't perform any transformation on the
  metadata in the input. This function assumes that for an input GRanges
  object, any metadata for each range is equally correct when inherited by
  each individual base in that range. In other words, the dataset's "signal"
  (usually readcounts) fundamentally belongs to a single basepair position.
}
\section{Motivation}{
 The motivating case for this function is a bigWig file
  (e.g. one imported by \code{rtracklayer}), as bigWig files typically use
  run-length compression on the data signal (the 'score' column), such that
  adjacent bases sharing the same signal are combined into a single range. As
  basepair-resolution genomic data is typically sparse, this compression has
  a minimal impact on memory usage, and removing it greatly enhances data
  handling as each index (each range) of the GRanges object corresponds to a
  single genomic position.
}

\section{Generating basepair-resolution GRanges from whole reads}{
 If working
  with a GRanges object containing whole reads, one can obtain base-pair
  resolution information by using the strand-specific function
  \code{\link[GenomicRanges:resize]{GenomicRanges::resize}} to select a
  single base from each read: set \code{width = 1} and use the \code{fix}
  argument to choose the strand-specific 5' or 3' end. Then, strand-specific
  coverage can be calculated using
  \code{\link[BRGenomics:getStrandedCoverage]{getStrandedCoverage}}.
}

\section{On the use of GRanges instead of GPos}{
 The
  \code{\link[GenomicRanges:GPos]{GPos}} class is a more suitable container
  for data of this type, as the GPos class is specific to 1-bp-wide ranges.
  However, in early testing, we encountered some kind of compatibility
  limitations with the newer GPos class, and have not re-tested it since. If
  you have feedback on switching to this class, please contact the author.
  Users can readily coerce a basepair-resolution GRanges object to a GPos
  object via \code{gp <- GPos(gr, score = score(gr))}.
}

\examples{
#--------------------------------------------------#
# Make a bigWig file single width
#--------------------------------------------------#

# get local address for an included bigWig file
bw_file <- system.file("extdata", "PROseq_dm6_chr4_plus.bw",
                       package = "BRGenomics")

# BRGenomics::import_bigWig automatically applies makeGRangesBRG;
# therefore will import using rtracklayer
bw <- rtracklayer::import.bw(bw_file)
strand(bw) <- "+"

range(width(bw))
length(bw)

# make basepair-resolution (single-width)
gr <- makeGRangesBRG(bw)

range(width(gr))
length(gr)
length(gr) == sum(width(bw))
sum(score(gr)) == sum(score(bw) * width(bw))

#--------------------------------------------------#
# Reverse using getStrandedCoverage
#--------------------------------------------------#
# -> for more examples, see getStrandedCoverage

undo <- getStrandedCoverage(gr, ncores = 2)

range(width(undo))
length(undo) == length(bw)
all(score(undo) == score(bw))
}
\seealso{
\code{\link[BRGenomics:getStrandedCoverage]{getStrandedCoverage}},
  \code{\link[GenomicRanges:resize]{GenomicRanges::resize()}}
}
\author{
Mike DeBerardine
}
